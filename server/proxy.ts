import express, { Request, Response, NextFunction } from "express";
import cors from "cors";
import fetch from "node-fetch";
import dotenv from "dotenv";
import path from "path";
import fs from "fs";

const INTERNAL_TEST_CONFIG = {
  model: "claude-3-haiku-20240307",
  maxTokens: 100, // –ú–∏–Ω–∏–º—É–º –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ —Ç–µ—Å—Ç–∞
  temperature: 0.3, // –°—Ç–∞–±–∏–ª—å–Ω–∞—è –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
} as const;

// –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã –¥–ª—è —Ç–∏–ø–∏–∑–∞—Ü–∏–∏
interface ClaudeMessage {
  role: string;
  content: string;
}

interface ClaudeRequestBody {
  model?: string;
  max_tokens?: number;
  temperature?: number;
  messages: ClaudeMessage[];
}

interface ClaudeContent {
  type: string;
  text: string;
}

interface ClaudeResponse {
  content: ClaudeContent[];
  model?: string;
  role?: string;
  stop_reason?: string;
  usage?: {
    input_tokens: number;
    output_tokens: number;
  };
}

interface ErrorResponse {
  error: string;
  details?: string;
  type?: string;
  timestamp: string;
}

// –ó–∞–≥—Ä—É–∂–∞–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è –∏–∑ .env
dotenv.config({ path: path.join(__dirname, ".env") });

const app = express();

const logsDir = path.join(__dirname, "../client/cypress/logs");
if (!fs.existsSync(logsDir)) fs.mkdirSync(logsDir, { recursive: true });
const serverLogPath = path.join(
  logsDir,
  `server_log_${new Date().toISOString().replace(/[:.]/g, "_")}.txt`
);
const serverLogStream = fs.createWriteStream(serverLogPath, { flags: "a" });
const originalConsoleLog = console.log;
console.log = (...args: unknown[]) => {
  originalConsoleLog(...args);
  serverLogStream.write(args.map(String).join(" ") + "\n");
};

// Middleware
app.use(
  cors({
    origin: ["http://localhost:5173", "http://localhost:3000"], // Vite –∏ React dev servers
    credentials: true,
  })
);
app.use(express.json({ limit: "10mb" })); // –£–≤–µ–ª–∏—á–µ–Ω–Ω—ã–π –ª–∏–º–∏—Ç –¥–ª—è –±–æ–ª—å—à–∏—Ö –ø—Ä–æ–º–ø—Ç–æ–≤

// –ü–æ–ª—É—á–∞–µ–º API –∫–ª—é—á –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
const API_KEY = process.env.CLAUDE_API_KEY;

if (!API_KEY) {
  console.error("‚ùå –û–®–ò–ë–ö–ê: CLAUDE_API_KEY –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ .env —Ñ–∞–π–ª–µ!");
  console.error("üìã –£–±–µ–¥–∏—Ç–µ—Å—å —á—Ç–æ —Ñ–∞–π–ª server/.env —Å–æ–¥–µ—Ä–∂–∏—Ç:");
  console.error("   CLAUDE_API_KEY=sk-ant-api03-–≤–∞—à-–∫–ª—é—á");
  process.exit(1);
}

console.log("‚úÖ Claude API –∫–ª—é—á –∑–∞–≥—Ä—É–∂–µ–Ω –∏–∑ .env");
console.log("üîë API –∫–ª—é—á –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å:", API_KEY.substring(0, 20) + "...");

// –ú–∞—Ä—à—Ä—É—Ç –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ä–∞–±–æ—Ç–æ—Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏
app.get("/health", (req: Request, res: Response) => {
  res.json({
    status: "ok",
    timestamp: new Date().toISOString(),
    hasApiKey: !!API_KEY,
    internalTestConfig: INTERNAL_TEST_CONFIG,
    note: "Configuration is managed by client (client/src/config/index.ts). Server acts as proxy without defaults.",
  });
});

// –û—Å–Ω–æ–≤–Ω–æ–π –º–∞—Ä—à—Ä—É—Ç –¥–ª—è Claude API
app.post("/api/claude", async (req: Request, res: Response) => {
  const startTime = Date.now();

  console.log("\nüî• ===== –ù–û–í–´–ô –ó–ê–ü–†–û–° –ö CLAUDE API =====");
  console.log("üïê –í—Ä–µ–º—è:", new Date().toISOString());
  console.log("üìù Request body keys:", Object.keys(req.body));

  // –í–∞–ª–∏–¥–∞—Ü–∏—è –∑–∞–ø—Ä–æ—Å–∞
  if (!req.body) {
    console.error("‚ùå –ü—É—Å—Ç–æ–µ —Ç–µ–ª–æ –∑–∞–ø—Ä–æ—Å–∞");
    return res.status(400).json({
      error: "Empty request body",
      timestamp: new Date().toISOString(),
    } as ErrorResponse);
  }

  const requestBody = req.body as ClaudeRequestBody;

  if (!requestBody.messages || !Array.isArray(requestBody.messages)) {
    console.error("‚ùå –û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –∏–ª–∏ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –ø–æ–ª–µ messages");
    return res.status(400).json({
      error: "Missing or invalid messages array",
      timestamp: new Date().toISOString(),
    } as ErrorResponse);
  }

  // –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –∑–∞–ø—Ä–æ—Å–∞
  console.log("üìä –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –∑–∞–ø—Ä–æ—Å–∞:");
  console.log("   Model:", requestBody.model || "–Ω–µ —É–∫–∞–∑–∞–Ω");
  console.log("   Max tokens:", requestBody.max_tokens || "–Ω–µ —É–∫–∞–∑–∞–Ω");
  console.log("   Temperature:", requestBody.temperature || "–Ω–µ —É–∫–∞–∑–∞–Ω");
  console.log("   Messages count:", requestBody.messages.length);

  // –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏–π —Å —Ç–∏–ø–∏–∑–∞—Ü–∏–µ–π
  requestBody.messages.forEach((msg: ClaudeMessage, index: number) => {
    console.log(`   Message ${index + 1}:`);
    console.log(`     Role: ${msg.role}`);
    console.log(`     Content length: ${msg.content?.length || 0} —Å–∏–º–≤–æ–ª–æ–≤`);
    if (msg.content && msg.content.length > 0) {
      console.log(
        `     First 200 chars: "${msg.content.substring(0, 200)}${msg.content.length > 200 ? "..." : ""}"`
      );
    }
  });

  // –í–∞–ª–∏–¥–∞—Ü–∏—è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –æ—Ç –∫–ª–∏–µ–Ω—Ç–∞
  if (!requestBody.model || !requestBody.max_tokens || requestBody.temperature === undefined) {
    console.error("‚ùå –ö–ª–∏–µ–Ω—Ç –Ω–µ –ø–µ—Ä–µ–¥–∞–ª –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã");
    console.error("   Model:", requestBody.model);
    console.error("   Max tokens:", requestBody.max_tokens);
    console.error("   Temperature:", requestBody.temperature);

    return res.status(400).json({
      error:
        "Missing required parameters: model, max_tokens, temperature must be provided by client",
      timestamp: new Date().toISOString(),
    } as ErrorResponse);
  }

  try {
    console.log("\nüöÄ –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å –∫ Claude API...");

    // –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º —Ç–µ–ª–æ –∑–∞–ø—Ä–æ—Å–∞ –¥–ª—è Claude
    const claudeRequestBody: ClaudeRequestBody = {
      model: requestBody.model!, // –ö–ª–∏–µ–Ω—Ç –í–°–ï–ì–î–ê –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç
      max_tokens: requestBody.max_tokens!, // –ö–ª–∏–µ–Ω—Ç –í–°–ï–ì–î–ê –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç
      temperature: requestBody.temperature!, // –ö–ª–∏–µ–Ω—Ç –í–°–ï–ì–î–ê –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç
      messages: requestBody.messages,
    };

    console.log("üì¶ –§–∏–Ω–∞–ª—å–Ω–∞—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∑–∞–ø—Ä–æ—Å–∞:");
    console.log("   Model:", claudeRequestBody.model);
    console.log("   Max tokens:", claudeRequestBody.max_tokens);
    console.log("   Temperature:", claudeRequestBody.temperature);
    console.log("   Messages count:", claudeRequestBody.messages.length);

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ –æ–∂–∏–¥–∞–µ–º—ã–º –∑–Ω–∞—á–µ–Ω–∏—è–º
    console.log("‚úÖ –ò—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –æ—Ç –∫–ª–∏–µ–Ω—Ç–∞");
    console.log("   –ò—Å—Ç–æ—á–Ω–∏–∫ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏: client/src/config/index.ts");
    console.log("   –°–µ—Ä–≤–µ—Ä —Ä–∞–±–æ—Ç–∞–µ—Ç –∫–∞–∫ –ø—Ä–æ–∫—Å–∏ –±–µ–∑ –¥–µ—Ñ–æ–ª—Ç–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π");

    console.log("üì¶ –§–∏–Ω–∞–ª—å–Ω–æ–µ —Ç–µ–ª–æ –∑–∞–ø—Ä–æ—Å–∞ –∫ Claude:", JSON.stringify(claudeRequestBody, null, 2));

    const response = await fetch("https://api.anthropic.com/v1/messages", {
      method: "POST",
      headers: {
        "x-api-key": API_KEY!,
        "anthropic-version": "2023-06-01",
        "content-type": "application/json",
      },
      body: JSON.stringify(claudeRequestBody),
    });

    const responseTime = Date.now() - startTime;
    console.log(`\nüì° –û—Ç–≤–µ—Ç –æ—Ç Claude API –ø–æ–ª—É—á–µ–Ω –∑–∞ ${responseTime}ms`);
    console.log("üìä Response status:", response.status);
    console.log("üìä Response ok:", response.ok);
    console.log("üìä Response headers:", Object.fromEntries(response.headers.entries()));

    // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—Å—Ç –æ—Ç–≤–µ—Ç–∞
    const responseText = await response.text();
    console.log("üìÑ Raw response length:", responseText.length);
    console.log("üìÑ Raw response (first 500 chars):", responseText.substring(0, 500));

    if (!response.ok) {
      console.error("‚ùå Claude API –≤–µ—Ä–Ω—É–ª –æ—à–∏–±–∫—É:");
      console.error("   Status:", response.status);
      console.error("   Response:", responseText);

      return res.status(response.status).json({
        error: `Claude API Error (${response.status})`,
        details: responseText,
        timestamp: new Date().toISOString(),
      } as ErrorResponse);
    }

    // –ü–∞—Ä—Å–∏–º JSON –æ—Ç–≤–µ—Ç
    let data: ClaudeResponse;
    try {
      data = JSON.parse(responseText) as ClaudeResponse;
      console.log("‚úÖ JSON —É—Å–ø–µ—à–Ω–æ —Ä–∞—Å–ø–∞—Ä—Å–µ–Ω");
      console.log("üì¶ Response data keys:", Object.keys(data));
      console.log("üì¶ Full response structure:", JSON.stringify(data, null, 2));
    } catch (parseError) {
      console.error("‚ùå –û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ JSON –æ—Ç–≤–µ—Ç–∞ –æ—Ç Claude:", parseError);
      console.error("üìÑ –ü—Ä–æ–±–ª–µ–º–Ω—ã–π —Ç–µ–∫—Å—Ç:", responseText);

      const errorMessage = parseError instanceof Error ? parseError.message : "Unknown parse error";

      return res.status(500).json({
        error: "Failed to parse Claude API response",
        details: errorMessage,
        rawResponse: responseText,
        timestamp: new Date().toISOString(),
      } as ErrorResponse);
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É –æ—Ç–≤–µ—Ç–∞
    if (data.content && Array.isArray(data.content) && data.content.length > 0) {
      console.log("‚úÖ –í–∞–ª–∏–¥–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –æ—Ç–≤–µ—Ç–∞ –æ—Ç Claude");
      console.log("üìù Content items count:", data.content.length);
      data.content.forEach((item: ClaudeContent, index: number) => {
        console.log(`   Content ${index + 1}:`);
        console.log(`     Type: ${item.type}`);
        console.log(`     Text length: ${item.text?.length || 0}`);
        if (item.text) {
          console.log(
            `     First 200 chars: "${item.text.substring(0, 200)}${item.text.length > 200 ? "..." : ""}"`
          );
        }
      });
    } else {
      console.warn("‚ö†Ô∏è –ù–µ–æ–∂–∏–¥–∞–Ω–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –æ—Ç–≤–µ—Ç–∞ –æ—Ç Claude");
      console.warn('Expected: { content: [{ type: "text", text: "..." }] }');
      console.warn("Received:", data);
    }

    console.log("‚úÖ –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ç–≤–µ—Ç –∫–ª–∏–µ–Ω—Ç—É");
    console.log("üî• ===== –ó–ê–ü–†–û–° –ó–ê–í–ï–†–®–ï–ù =====\n");

    res.json(data);
  } catch (err) {
    const responseTime = Date.now() - startTime;
    console.error(`\n‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–æ–∫—Å–∏ —Å–µ—Ä–≤–µ—Ä–∞ (${responseTime}ms):`);

    // –ü—Ä–∞–≤–∏–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ unknown error —Ç–∏–ø–∞
    const error = err as Error;
    console.error("Error type:", error.constructor?.name || "Unknown");
    console.error("Error message:", error.message || "No message");
    console.error("Error stack:", error.stack || "No stack");

    res.status(500).json({
      error: "Proxy server error",
      details: error.message || "Unknown error",
      type: error.constructor?.name || "Unknown",
      timestamp: new Date().toISOString(),
    } as ErrorResponse);
  }
});

// Batch endpoints –¥–ª—è –ø–∞–∫–µ—Ç–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏
app.post("/api/claude/batch", async (req: Request, res: Response) => {
  try {
    const anthropicRes = await fetch("https://api.anthropic.com/v1/messages/batches", {
      method: "POST",
      headers: {
        "x-api-key": API_KEY!,
        "anthropic-version": "2023-06-01",
        "content-type": "application/json",
      },
      body: JSON.stringify(req.body),
    });
    const json = await anthropicRes.json();
    res.status(anthropicRes.status).json(json);
  } catch (error) {
    console.error("Batch creation error:", error);
    res.status(500).json({ error: "Batch request failed" });
  }
});

app.get("/api/claude/batch/:id", async (req: Request, res: Response) => {
  try {
    const anthropicRes = await fetch(
      `https://api.anthropic.com/v1/messages/batches/${req.params.id}`,
      {
        method: "GET",
        headers: {
          "x-api-key": API_KEY!,
          "anthropic-version": "2023-06-01",
        },
      }
    );
    const json = await anthropicRes.json();
    res.status(anthropicRes.status).json(json);
  } catch (error) {
    console.error("Batch status error:", error);
    res.status(500).json({ error: "Batch status failed" });
  }
});

// –ú–∞—Ä—à—Ä—É—Ç –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ Claude API
app.post("/api/claude/test", async (req: Request, res: Response) => {
  console.log("\nüß™ ===== INTERNAL API TEST =====");
  console.log("‚ö†Ô∏è  –í–Ω–∏–º–∞–Ω–∏–µ: —ç—Ç–æ internal —Ç–µ—Å—Ç —Å —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏");
  console.log("‚ö†Ô∏è  –û—Å–Ω–æ–≤–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –æ—Ç –∫–ª–∏–µ–Ω—Ç–∞");

  try {
    // –ó–ê–ú–ï–ù–ò–¢–¨ testMessage –Ω–∞:
    const testMessage: ClaudeRequestBody = {
      model: INTERNAL_TEST_CONFIG.model,
      max_tokens: INTERNAL_TEST_CONFIG.maxTokens,
      temperature: INTERNAL_TEST_CONFIG.temperature,
      messages: [
        {
          role: "user",
          content: 'Say \'Hello, I am working!\' in JSON format: {"message": "your response"}',
        },
      ],
    };

    console.log("üì¶ Internal test configuration:");
    console.log("   Model:", testMessage.model);
    console.log("   Max tokens:", testMessage.max_tokens);
    console.log("   Temperature:", testMessage.temperature);
    console.log("   Purpose: API connectivity test only");

    console.log("üöÄ –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–µ—Å—Ç–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å...");

    const response = await fetch("https://api.anthropic.com/v1/messages", {
      method: "POST",
      headers: {
        "x-api-key": API_KEY!,
        "anthropic-version": "2023-06-01",
        "content-type": "application/json",
      },
      body: JSON.stringify(testMessage),
    });

    const data = (await response.json()) as ClaudeResponse;

    if (response.ok) {
      console.log("‚úÖ –¢–µ—Å—Ç —É—Å–ø–µ—à–µ–Ω! Claude API —Ä–∞–±–æ—Ç–∞–µ—Ç");
      res.json({
        success: true,
        message: "Claude API connection test successful",
        claudeResponse: data,
        timestamp: new Date().toISOString(),
      });
    } else {
      console.error("‚ùå –¢–µ—Å—Ç –ø—Ä–æ–≤–∞–ª–µ–Ω:", data);
      res.status(500).json({
        success: false,
        error: "Claude API test failed",
        details: data,
        timestamp: new Date().toISOString(),
      });
    }
  } catch (err) {
    const error = err as Error;
    console.error("‚ùå –û—à–∏–±–∫–∞ —Ç–µ—Å—Ç–∞:", error);
    res.status(500).json({
      success: false,
      error: "Test connection failed",
      details: error.message,
      timestamp: new Date().toISOString(),
    });
  }
});

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ 404
app.use("*", (req: Request, res: Response) => {
  console.log(`‚ùì 404: ${req.method} ${req.originalUrl}`);
  res.status(404).json({
    error: "Endpoint not found",
    available: ["/health", "/api/claude", "/api/claude/test"],
    timestamp: new Date().toISOString(),
  } as ErrorResponse);
});

// –ì–ª–æ–±–∞–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ —Å –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π —Ç–∏–ø–∏–∑–∞—Ü–∏–µ–π Express middleware
// eslint-disable-next-line @typescript-eslint/no-unused-vars
app.use((err: Error, req: Request, res: Response, next: NextFunction) => {
  console.error("üí• –ù–µ–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞:", err);
  res.status(500).json({
    error: "Internal server error",
    details: err.message,
    timestamp: new Date().toISOString(),
  } as ErrorResponse);
});

const PORT = process.env.PORT || 3001;

app.listen(PORT, () => {
  console.log("\nüöÄ ===== –ü–†–û–ö–°–ò –°–ï–†–í–ï–† –ó–ê–ü–£–©–ï–ù =====");
  console.log(`üåê –°–ª—É—à–∞–µ—Ç –ø–æ—Ä—Ç: ${PORT}`);
  console.log(`üè• Health check: http://localhost:${PORT}/health`);
  console.log(`üß™ Test endpoint: http://localhost:${PORT}/api/claude/test`);
  console.log(`ü§ñ Claude API endpoint: http://localhost:${PORT}/api/claude`);
  console.log("=====================================\n");
});
